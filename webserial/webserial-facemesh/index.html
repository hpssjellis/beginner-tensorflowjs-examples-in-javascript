

<!-- Copyright 2020 Google LLC. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================-->


<head>

<script src="https://cdn.jsdelivr.net/npm/three@0.117.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/scatter-gl@0.0.5/lib/scatter-gl.min.js"></script> 
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/facemesh@0.0.3"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@2.0.0/dist/tf-backend-wasm.js"></script>

    
<!--   For latest versions Google npm @tensorflow/tfjs  etc or try running without @2.0.0 version numbers      -->    
<!--   <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>   -->

<script>
   // needed to save the exports for the polyfill
    var exports = {};
    let myOn = true
</script>
    
<script src="https://cdn.jsdelivr.net/npm/web-serial-polyfill@1.0.13/dist/serial.js"> </script>   <!-- is this done in the js file-->
    
<script src="./triangulation.js"></script>
<script src="./rocksetta-webserial-polyfil-01.js"></script>
   
    
    
<style>
  .canvas-wrapper, #scatter-gl-container {
    display: inline-block;
    vertical-align: top;
  }

  #scatter-gl-container {
    border: solid 1px black;
    position: relative;
  }

  /* center the canvas within its wrapper */
  #scatter-gl-container canvas {
    transform: translate3d(-50%, -50%, 0);
    left: 50%;
    top: 50%;
    position: absolute;
  }
</style>
</head>
<body>
  <div id="main">
    <div class="container">
      <div class="canvas-wrapper">
        <canvas id="output"></canvas>
        <video id="video" playsinline style="
          -webkit-transform: scaleX(-1);
          transform: scaleX(-1);
          visibility: hidden;
          width: auto;
          height: auto;
          ">
        </video>
      </div>
      <div id="scatter-gl-container"></div>
    </div>
  </div>
    

    
    
   <h6> Version 0.3.0-10 </h6>

    
<input type=button value="new connect" onclick="{
  if (navigator.serial) {
     connectSerial();
  } else {
    document.getElementById('myDiv02').innerHTML = 'Web Serial API not supported. Switching to Polyfill<br>'
    myPoly()
  }
}">
        
<input type=button value="Just Polyfil connect" onclick="{
    myPoly()
}"><br><br>

<input type=text id="mySendText" value="a">
<input type=button value="send" onclick="{ mySendIt(document.getElementById('mySendText').value) }"><br><br>

<input type=button value="send 'a' LED On" onclick="{mySendIt('a')}"><br><br>
<input type=button value="send 'b' LED Off" onclick="{mySendIt('b')}"><br><br>

<div id="target">...</div> <br><br>
<div id="myDiv03">...</div>      
<div id="myDiv01">...</div>   

<div id="myDiv02">...</div>        
    
    
    


  Here is the latest sketch I am using. The .txt is for viewing the .ino is to download<br>
 <li><a href="https://github.com/hpssjellis/web-serial-polyfill/blob/main/arduino04-webserial.txt">arduino04-webserial.txt</a>  This arduino sketch can be viewed
<li><a href="https://github.com/hpssjellis/web-serial-polyfill/blob/main/arduino04-webserial.ino">arduino04-webserial.ino</a>  Click to download: Note: New ArduinoWebSerial testing code. Make sure in Arduino Serial Monitor you don't send a new-line
 

  This Github at <a href="https://github.com/hpssjellis/web-serial-polyfill">https://github.com/hpssjellis/web-serial-polyfill</a>
<p><small>Original Demo from <a href="https://codelabs.developers.google.com/codelabs/web-serial/" target="_blank" rel="noopener">Google Developers</a> codelabs.</small></p>    
    
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>


<!-- <script src="index.js"></script>  -->






<!--  

----------------------------------old index.js merged here----------------------------------------------------

-->

<script>

/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */



/**
function tfjsWasm.setWasmPath(
    `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${
        version}/dist/tfjs-backend-wasm.wasm`);
*/


function isMobile() {
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isiOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  return isAndroid || isiOS;
}

function drawPath(ctx, points, closePath) {
  const region = new Path2D();
  region.moveTo(points[0][0], points[0][1]);
  for (let i = 1; i < points.length; i++) {
    const point = points[i];
    region.lineTo(point[0], point[1]);
  }

  if (closePath) {
    region.closePath();
  }
  ctx.stroke(region);
}

let model, ctx, videoWidth, videoHeight, video, canvas,
    scatterGLHasInitialized = false, scatterGL;

const VIDEO_SIZE = 500;
const mobile = isMobile();
// Don't render the point cloud on mobile in order to maximize performance and
// to avoid crowding limited screen space.
const renderPointcloud = mobile === false;
//const stats = new Stats();
const state = {
  backend: 'wasm',
  maxFaces: 10,
  triangulateMesh: false
};

if (renderPointcloud) {
  state.renderPointcloud = true;
}

function setupDatGui() {
  const gui = new dat.GUI();
  gui.add(state, 'backend', ['wasm', 'webgl', 'cpu'])
      .onChange(async backend => {
        await tf.setBackend(backend);
      });

  gui.add(state, 'maxFaces', 1, 20, 1).onChange(async val => {
    model = await facemesh.load({maxFaces: val});
  });

  gui.add(state, 'triangulateMesh');

  if (renderPointcloud) {
    gui.add(state, 'renderPointcloud').onChange(render => {
      document.querySelector('#scatter-gl-container').style.display =
          render ? 'inline-block' : 'none';
    });
  }
}

async function setupCamera() {
  video = document.getElementById('video');

  const stream = await navigator.mediaDevices.getUserMedia({
    'audio': false,
    'video': {
      facingMode: 'user',
      // Only setting the video to a specified size in order to accommodate a
      // point cloud, so on mobile devices accept the default size.
      width: mobile ? undefined : VIDEO_SIZE,
      height: mobile ? undefined : VIDEO_SIZE
    },
  });
  video.srcObject = stream;

  return new Promise((resolve) => {
    video.onloadedmetadata = () => {
      resolve(video);
    };
  });
}

async function renderPrediction() {
 // stats.begin();

  const predictions = await model.estimateFaces(video);
   // console.log(predictions[0].faceInViewConfidence)
  ctx.drawImage(
      video, 0, 0, videoWidth, videoHeight, 0, 0, canvas.width, canvas.height);

  document.getElementById('myDiv01').innerHTML = '' 
  if (predictions.length > 0) {
    predictions.forEach(prediction => {
      try {
        document.getElementById('myDiv01').innerHTML += 'Confidence: ' + prediction.faceInViewConfidence.toFixed(4) + '<br>'
        // console.log(prediction.faceInViewConfidence.toFixed(4))
        const keypoints = prediction.scaledMesh;
       // console.log(keypoints[234])
        let myFaceWidth =  keypoints[454][0] - keypoints[234][0]  // x = 0,  y=1
        let myDistanceCutoff = 50
        let myCloseness =  (myFaceWidth - myDistanceCutoff)/ myDistanceCutoff    // myDistanceCutoff default ~50
      //  if (myCloseness < 0 ){myCloseness = 0}
        
        let myMouthOpenCutoff = 0.03
        let myMouthOpen = (keypoints[14][1] - keypoints[13][1])   // x = 0,  y=1
        let myMouthShut =  ( (myMouthOpen )/ (myMouthOpenCutoff * myFaceWidth) )   // myMouthOpenCutoff default ~0.03  
          
        
        if (myMouthOpen > 10 && myOn ){  // random cutoff between open and closed  
            // do nothing since already done
        } else {
          myOn = true  
          mySendIt('b')  
        }
        if (myMouthOpen <= 10 && myOn ){  // random cutoff between open and closed  
            // do nothing since already done
            myOn = false
            mySendIt('b')  
        } else {
          // do nothing since myOn already false and data sent  

        }          
          
          
          
          
          
     //          mySendIt('b')  // arduino off or on, depends on the coding     
          
        
        document.getElementById('myDiv03').innerHTML = 'myFaceWidth: '+ myFaceWidth + ', myCloseness: ' + myCloseness  + ', myMouthOpen: ' +  myMouthOpen   + ', myMouthShut: ' +   myMouthShut  + '<br>'
      }
      catch(err){
      document.getElementById('myDiv01').innerHTML = err.message;
      }
        
      const keypoints = prediction.scaledMesh;
//  console.log(keypoints[0][2])
      if (state.triangulateMesh) {
        for (let i = 0; i < TRIANGULATION.length / 3; i++) {
          const points = [
            TRIANGULATION[i * 3], TRIANGULATION[i * 3 + 1],
            TRIANGULATION[i * 3 + 2]
          ].map(index => keypoints[index]);

          drawPath(ctx, points, true);
        }
      } else {
        for (let i = 0; i < keypoints.length; i++) {
          const x = keypoints[i][0];
          const y = keypoints[i][1];

          ctx.beginPath();
          ctx.arc(x, y, 1 /* radius */, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    });

    if (renderPointcloud && state.renderPointcloud && scatterGL != null) {
      const pointsData = predictions.map(prediction => {
        let scaledMesh = prediction.scaledMesh;
        return scaledMesh.map(point => ([-point[0], -point[1], -point[2]]));
      });

      let flattenedPointsData = [];
      for (let i = 0; i < pointsData.length; i++) {
        flattenedPointsData = flattenedPointsData.concat(pointsData[i]);
      }
      const dataset = new ScatterGL.Dataset(flattenedPointsData);

      if (!scatterGLHasInitialized) {
        scatterGL.render(dataset);
      } else {
        scatterGL.updateDataset(dataset);
      }
      scatterGLHasInitialized = true;
    }
  }

//  stats.end();
  requestAnimationFrame(renderPrediction);
};

async function main() {
  await tf.setBackend(state.backend);
  setupDatGui();

  //stats.showPanel(0);  // 0: fps, 1: ms, 2: mb, 3+: custom
//  document.getElementById('main').appendChild(stats.dom);

  await setupCamera();
  video.play();
  videoWidth = video.videoWidth;
  videoHeight = video.videoHeight;
  video.width = videoWidth;
  video.height = videoHeight;

  canvas = document.getElementById('output');
  canvas.width = videoWidth;
  canvas.height = videoHeight;
  const canvasContainer = document.querySelector('.canvas-wrapper');
  canvasContainer.style = `width: ${videoWidth}px; height: ${videoHeight}px`;

  ctx = canvas.getContext('2d');
  ctx.translate(canvas.width, 0);
  ctx.scale(-1, 1);
  ctx.fillStyle = '#32EEDB';
  ctx.strokeStyle = '#32EEDB';
  ctx.lineWidth = 0.5;

  model = await facemesh.load({maxFaces: state.maxFaces});
   // console.log(model)
  renderPrediction();

  if (renderPointcloud) {
    document.querySelector('#scatter-gl-container').style =
        `width: ${VIDEO_SIZE}px; height: ${VIDEO_SIZE}px;`;

    scatterGL = new ScatterGL(
        document.querySelector('#scatter-gl-container'),
        {'rotateOnStart': false, 'selectEnabled': false});
  }
};

main();
      
</script>
